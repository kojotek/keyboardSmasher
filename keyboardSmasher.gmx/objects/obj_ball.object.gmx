<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_ball</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>start_position_x = x;
horizontal_speed = 4;
last_known_y = y;
next_y = y;
speed_factor = 1;
blink = 0;

mid_air_start_x = x;
mid_air_start_y = y;
jump_height = 96;
jump_length = 32 * horizontal_speed;
mid_air_type = MID_AIR_TYPE_FALL;
mid_air = false;

dash_length = 256;
dash_start_x = -1000;
dash_available = false;

short_jump_key = false;
long_jump_key = false;
dash_key = false;
slide_key = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/************************************************************
    BULLET COLLISION
************************************************************/

var vertical_direction = sign(next_y-y);
var collision_occured = false;


//jezeli obiekt spada, lub porusza sie w gore
if (vertical_direction != CONSTANT_ALTITUDE){


    //petla bullet collision
    do{
        if (place_meeting(x,y,obj_collidable)){
            collision_occured = true;
            event_perform(ev_other, GO_OUT_FROM_OBJECT);        //wychodzenie z kolidujacych obiektow
            break;
        }
        else{
            y += 31 * vertical_direction;
        }
    }
    until(  !((y &lt; next_y) &amp;&amp; (vertical_direction == DOWNWARDS)) 
        &amp;&amp;  !((y &gt; next_y) &amp;&amp; (vertical_direction == UPWARDS)))
    
        
    //jezeli kolizja nie zaszla, ustaw obiekt tam, gdzie powinien finalnie sie znalezc
    if (!collision_occured){
        y = next_y;
    }

}

//po calej petli wychodzimy z kolizji jeszcze raz
event_perform(ev_other, GO_OUT_FROM_OBJECT);


/************************************************************
    Kontakt z gruntem
************************************************************/

if (position_meeting(x, y+17, obj_collidable)){
    mid_air_start_x = x;
    mid_air_start_y = y;
    mid_air_type = MID_AIR_TYPE_FALL;
    mid_air = false;
    jump_height = 320;
    jump_length = 64 * horizontal_speed;
    dash_available = true;
}
else{
    mid_air = true;
}


/************************************************************
    Kontakt z sufitem
************************************************************/

if (position_meeting(x, y-17, obj_collidable)){
    if (y&lt;last_known_y)
    {
        mid_air_start_x = x;
        mid_air_start_y = y;
        mid_air_type = MID_AIR_TYPE_FALL;
        jump_height = 320;
        jump_length = 64 * horizontal_speed;
    }
}


/************************************************************
************************************************************/

last_known_y = y;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//last_known_x = 0;
short_jump_key = keyboard_check(ord('Z'));
long_jump_key = keyboard_check(ord('X'));
dash_key = keyboard_check(ord('C'));
slide_key = keyboard_check(ord('V'));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*************************************************************************************************
    Oczyt pozycji glowicy na tasmie nie jest dokladny. Sprawdzajac pozycje co obieg petli
    otrzymujemy wynik podobny do tego: 0,0,0,3,3,7,7,7,12,12,12,12,12,20,20,20,20...
    Jako, ze pozycja bohatera uwarunkowana jest od tego odczytu, posilkujemy sie odczytem
    zegara. Jezeli dwa ostatnie odczyty glowicy sa identyczne, przesuwamy bohatera
    o odleglosc wynikajaca z dlugosci klatki.
*************************************************************************************************/

if (global.current_music_controller.head_position != global.current_music_controller.last_known_head_position){
    
    //pozycja pilki = pozycja startowa * wielkosc kafla * BPS * szybkosc obiektu * (pozycja glowicy + przesuniecie tasmy);
    var computed_x = start_position_x + 32 * (global.current_music_controller.tempo / 60) * horizontal_speed * (global.current_music_controller.head_position + global.current_music_controller.shift);
    speed_factor = 1 - (x - computed_x)/20;
    speed_factor = clamp(0.5, speed_factor, 1.4);
}
else{
    x += 32 * global.current_music_controller.tempo/60 * horizontal_speed * (global.current_time_controller.frame_time/1000) * speed_factor;
}


/*************************************************************************************************
    obsluga skokow
*************************************************************************************************/

if (short_jump_key &amp;&amp; !mid_air){
    mid_air = true;
    mid_air_type = MID_AIR_TYPE_JUMP;
    mid_air_star_x = x;
    mid_air_star_y = y;
    jump_height = 160;
    jump_length = 32 * horizontal_speed - ((x mod 32) &lt; 16) * (x mod 32) + ((x mod 32) &gt; 16) * (32-(x mod 32));
}

if (long_jump_key &amp;&amp; !mid_air){
    mid_air = true;
    mid_air_type = MID_AIR_TYPE_JUMP;
    mid_air_star_x = x;
    mid_air_star_y = y;
    jump_height = 320;
    jump_length = 64 * horizontal_speed - ((x mod 32) &lt; 16) * (x mod 32) + ((x mod 32) &gt; 16) * (32-(x mod 32));
}


/*************************************************************************************************
    obsluga szybowania
*************************************************************************************************/

if (dash_key &amp;&amp; dash_available &amp;&amp; mid_air){
    dash_start_x = x;
    dash_available = false;
}


/*************************************************************************************************
    obsluga slizgu
*************************************************************************************************/

if (slide_key &amp;&amp; !mid_air){
    slide_start_x = x;
}


/*************************************************************************************************
    Liczymy nastepna wartosc y.
*************************************************************************************************/

var computed_next_y =  mid_air_start_y + (4*(jump_height/(jump_length*jump_length))*(x-mid_air_start_x)*(x-mid_air_start_x) - 4*mid_air_type*(x-mid_air_start_x)*(jump_height/jump_length) );


/*************************************************************************************************
    Jezeli szybujemy, nastepny y bedzie taki sam, jak obecny. 
    Jezeli nie, przypisujemy mu uprzednio wyliczana wartosc.
*************************************************************************************************/

if (x &lt; dash_start_x + dash_length )
{
    //jezeli juz wpasowalismy sie w siatke poziomu...
    if (y mod 32 == 0){
        next_y = y;
        mid_air_start_x = x;
        mid_air_start_y = y;
    }
    else{
        //obliczamy wysokosc rozpoczecia szybowania. Jezeli obiekt przekroczy ten pulap, zostanie do niego zrownany
        var y_increases = (computed_next_y &gt; y);
        var dash_alititude = ((y div 32) + y_increases) * 32;
        if ((y_increases &amp;&amp; computed_next_y &gt; dash_alititude) || (!y_increases &amp;&amp; computed_next_y &lt; dash_alititude)){
            y = dash_alititude;
            next_y = y;
            jump_height = 320;
            jump_length = 64 * horizontal_speed;
            mid_air_type = MID_AIR_TYPE_FALL;
        }
        else{
            next_y = computed_next_y;
        }
    }
}
else
{
    if (mid_air){
       next_y = computed_next_y;
    }
}



blink = (128 - (x mod 128))/256;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>while (position_meeting(x, y+16, obj_collidable))
{
    y = ceil(y)-1;
}

while (position_meeting(x, y-16, obj_collidable))
{
    y = floor(y)+1;
}

while (position_meeting(x+16, y, obj_collidable))
{
    x = floor(x)-1;
    audio_stop_all();
    room_restart();
}

while (position_meeting(x-16, y, obj_collidable))
{
    x = ceil(x)+1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_xview[0] = x-200;
draw_self();

draw_set_alpha(0);
if (x&gt;=2600){
draw_set_alpha(blink/2);
}
draw_rectangle_colour(0,0,100000,1000,c_white,c_white,c_white,c_white, 0);
draw_set_alpha(1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>audio_stop_all();
room_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
